package rtss.data.curves;

import org.apache.commons.math3.analysis.UnivariateFunction;

import rtss.data.bin.Bin;
import rtss.data.bin.Bins;
import rtss.math.algorithms.GoldenSectionSearch;
import rtss.math.interpolate.mpspline.MeanPreservingIntegralSpline;

/*
 * Tune the curve generated by ConstrainedCubicSpline
 */
public class TuneCCS
{
    private Bin[] bins;
    private MeanPreservingIntegralSpline.Options options;
    private final double[] curve_0;
    private final int ppy;
    
    public TuneCCS(Bin[] bins, MeanPreservingIntegralSpline.Options options, final double[] curve_0) throws Exception
    {
        this.bins = bins;
        this.options = options.clone();
        this.curve_0 = curve_0;
        this.ppy = CurveUtil.ppy(curve_0, bins);
    }
    
    /*
     * Find the value of f1.n parameter for the CCS that makes the last segment least curved (most straight)
     */
    public double tuneLastSegment() throws Exception
    {
        double[] seg;
        Bin lastBin = Bins.lastBin(bins);
        double a2, a1;
        
        seg = CurveUtil.seg(curve_0, lastBin, bins, ppy);
        double c0 = curvature(seg);
        double v0 = curve_0[curve_0.length - 1];
        
        CurvatureFunction cf = new CurvatureFunction(this, lastBin);
        
        /*
         * Drift up by 1% from v0 while curvature keeps decreasing compared to last measurement.
         * Record as @a2 the first v-value that resulted in increase. 
         */
        double clast = c0;
        double v = v0;
        for (;;)
        {
            v += v * 0.01;
            double c = cf.value(v);
            if (c > clast)
            {
                a2 = v;
                // c2 = c;
                break;
            }
            clast = c;
        }
        
        /*
         * Drift down by 1% from v0 while curvature keeps decreasing compared to last measurement.
         * Record as @a1 the first v-value that resulted in increase. 
         */
        clast = c0;
        v = v0;
        for (;;)
        {
            v -= v * 0.01;
            double c = cf.value(v);
            if (c > clast)
            {
                a1 = v;
                // c1 = c;
                break;
            }
            clast = c;
        }
        
        /*
         * Find local minimum of @cf
         */
        double[] aa = GoldenSectionSearch.find_min(cf, a1, a2, v0 * 0.001);
        return (aa[0] + aa[1]) / 2;
    }

    /*
     * Produce the metric of how much the curve is bent 
     */
    private static double curvature(double[] y)
    {
        double[] dy1 = derivative(y);
        double[] dy2 = derivative(dy1);
        double sum = 0;
        for (double d : dy2)
            sum += Math.abs(d);
        return sum;
    }

    private static double[] derivative(double[] y)
    {
        double[] dy = new double[y.length - 1];
        for (int k = 0; k < dy.length; k++)
            dy[k] = y[k + 1] - y[k];
        return dy;
    }
    
    public static class CurvatureFunction implements UnivariateFunction
    {
        private TuneCCS t;
        private Bin bin;
        
        CurvatureFunction(TuneCCS t, Bin bin)
        {
            this.t = t;
            this.bin = bin;
        }
        
        @Override
        public double value(double v)
        {
            try
            {
                t.options.splineParams("f1.n", v);
                double[] yyy = MeanPreservingIntegralSpline.eval(t.bins, t.options);
                double[] seg = CurveUtil.seg(yyy, bin, t.bins, t.ppy);
                return curvature(seg);
            }
            catch (Throwable t)
            {
                throw new RuntimeException(t.getLocalizedMessage(), t); 
            }
        }
    }
}
